# Cursor AI 코딩 규칙

<!--
  메타데이터 섹션: 규칙의 버전과 목적을 명시
  이 섹션은 AI가 규칙의 컨텍스트를 이해하는 데 도움이 됩니다
-->
## 📋 메타데이터
- 버전: 1.0.0
- 마지막 업데이트: 2024
- 목적: 일관된 코드 품질과 개발 워크플로우 유지

<!-- ============================================ -->
<!-- 핵심 원칙: 모든 규칙의 기반이 되는 기본 원칙 -->
<!-- ============================================ -->

## 🎯 핵심 원칙

### 커뮤니케이션
- 항상 한국어로 응답합니다
- 기술 용어는 필요시 영어를 병기하되, 설명은 한국어로 작성합니다
- 사용자 질문에 대해 명확하고 구체적으로 답변합니다

### 코드 품질
- 코드는 명확하고 읽기 쉽게 작성합니다
- 복잡한 로직은 단계별로 분해하여 이해하기 쉽게 만듭니다
- 주석은 "왜"를 설명하는 데 집중합니다 (코드 자체가 "무엇"을 보여줌)

<!-- ============================================ -->
<!-- 코드 스타일: 네이밍 컨벤션 및 포맷팅 -->
<!-- ============================================ -->

## 📝 코드 스타일

### 네이밍 컨벤션
- 변수명: camelCase (예: `userName`, `isActive`)
- 상수명: UPPER_SNAKE_CASE (예: `MAX_RETRY_COUNT`, `API_BASE_URL`)
- 함수명: 동사로 시작하는 camelCase (예: `getUserData`, `validateInput`)
- 클래스명: PascalCase (예: `UserService`, `ApiClient`)
- 인터페이스/타입: PascalCase, 접두사 I는 선택적 (예: `UserConfig`, `IApiResponse`)
- 파일명: kebab-case 또는 camelCase (프로젝트 컨벤션에 따름)

### 포맷팅
- 들여쓰기: 스페이스 2개 또는 탭 (프로젝트 설정에 따름)
- 최대 줄 길이: 100자 (프로젝트 설정에 따라 조정 가능)
- 세미콜론: 프로젝트 컨벤션에 따름
- 따옴표: 일관성 유지 (싱글 또는 더블, 프로젝트 설정에 따름)

<!-- ============================================ -->
<!-- 프로젝트 구조: 파일 및 폴더 조직 -->
<!-- ============================================ -->

## 📁 프로젝트 구조

### 폴더 구성
- 컴포넌트: 기능별로 폴더를 구성합니다
- 재사용 가능한 유틸리티: `utils/` 또는 `lib/` 폴더로 분리합니다
- 설정 파일: 루트 또는 `config/` 폴더에 위치시킵니다
- 타입 정의: `types/` 또는 `@types/` 폴더에 집중 관리합니다
- 상수: `constants/` 폴더에 분류하여 관리합니다

### 파일 구조
- 하나의 파일에는 하나의 주요 기능만 포함합니다
- 파일 크기는 300줄 이하를 권장합니다 (복잡도에 따라 조정)
- 관련된 기능은 같은 파일에 그룹화합니다

<!-- ============================================ -->
<!-- 코드 품질: 에러 처리, 성능, 보안 -->
<!-- ============================================ -->

## 🔒 에러 처리

### 기본 원칙
- 모든 비동기 작업에는 에러 처리를 포함합니다
- 사용자에게 명확하고 이해하기 쉬운 에러 메시지를 제공합니다
- 개발자를 위한 상세한 에러 정보는 로그에 기록합니다

### 구현 가이드
- try-catch 블록을 적절히 사용합니다
- 에러 타입을 명시적으로 처리합니다
- 기본값(fallback)을 제공할 수 있는 경우 제공합니다
- 에러 발생 시 로깅을 통해 디버깅을 용이하게 합니다

## ⚡ 성능 최적화

### 일반 원칙
- 불필요한 리렌더링을 방지합니다
- 메모이제이션을 적절히 활용합니다 (과도한 사용은 피합니다)
- 대용량 데이터 처리는 최적화된 방법을 사용합니다

### 최적화 전략
- 지연 로딩(lazy loading)을 적절히 활용합니다
- 불필요한 API 호출을 방지합니다
- 캐싱 전략을 고려합니다
- 성능 병목 지점을 프로파일링하여 확인합니다

## 🛡️ 보안

### 기본 원칙
- 민감한 정보는 환경 변수로 관리합니다
- 사용자 입력은 항상 검증합니다
- SQL 인젝션 및 XSS 공격을 방지합니다

### 보안 체크리스트
- 환경 변수는 `.env.example` 파일에 문서화합니다
- 입력 검증은 서버와 클라이언트 양쪽에서 수행합니다
- 인증/인가 로직은 명확하고 안전하게 구현합니다
- 의존성 보안 업데이트를 정기적으로 확인합니다

<!-- ============================================ -->
<!-- 개발 워크플로우: 테스트, 문서화, 리뷰 -->
<!-- ============================================ -->

## 🧪 테스트

### 테스트 원칙
- 중요한 로직은 테스트 코드를 작성합니다
- 테스트는 명확하고 독립적으로 작성합니다
- 테스트 이름은 무엇을 테스트하는지 명확히 표현합니다

### 테스트 구조
- 단위 테스트: 개별 함수/메서드 테스트
- 통합 테스트: 여러 컴포넌트 간 상호작용 테스트
- E2E 테스트: 주요 사용자 시나리오 테스트

## 📚 문서화

### 코드 문서화
- 복잡한 로직은 주석으로 설명합니다
- API는 JSDoc/TSDoc 형식으로 문서화합니다
- 함수/메서드는 목적, 매개변수, 반환값을 문서화합니다

### 프로젝트 문서화
- README는 프로젝트 설정 및 사용법을 포함합니다
- 주요 변경사항은 CHANGELOG에 기록합니다
- 아키텍처 결정은 ADR(Architecture Decision Records)로 문서화합니다

## 🔀 Pull Request (PR)

### 브랜치 전략
- Git Flow 방식을 기본으로 사용합니다
- Feature/Bugfix: `develop` 브랜치에서 분기
- Hotfix: `main` 브랜치에서 분기
- Release: `develop` 브랜치에서 분기

### PR 생성 규칙
- PR 제목은 `[타입] 간단한 설명` 형식을 따릅니다
- PR 본문은 구조화된 템플릿을 사용합니다
- PR 생성 전 체크리스트를 확인합니다
- 관련 이슈가 있으면 연결합니다

### 커밋 메시지
- Conventional Commits 형식을 따릅니다
- 커밋 타입을 명확히 지정합니다 (feat, fix, docs 등)
- 제목은 50자 이내로 간결하게 작성합니다

자세한 내용은 `.cursor/rules/workflow-rules/pr.md` 파일을 참고하세요.

<!-- ============================================ -->
<!-- 기술 스택별 규칙: 필요시 프로젝트에 맞게 수정 -->
<!-- ============================================ -->

## 🔧 기술 스택별 규칙

### TypeScript/JavaScript
- 타입을 명시적으로 정의합니다 (any 사용 최소화)
- 옵셔널 체이닝과 nullish coalescing을 적절히 활용합니다
- async/await를 Promise.then()보다 선호합니다

### React (해당하는 경우)
- 함수형 컴포넌트를 사용합니다
- 커스텀 훅으로 로직을 재사용합니다
- props 타입을 명시적으로 정의합니다

### Node.js (해당하는 경우)
- 비동기 작업은 async/await를 사용합니다
- 에러는 적절한 HTTP 상태 코드와 함께 반환합니다
- 미들웨어는 단일 책임 원칙을 따릅니다

<!-- ============================================ -->
<!-- AI 어시스턴트 지침: Cursor AI가 따라야 할 규칙 -->
<!-- ============================================ -->

## 🤖 AI 어시스턴트 지침

### 코드 생성 시
- 기존 코드 스타일과 패턴을 따릅니다
- 사용자가 요청한 기능만 구현합니다 (과도한 기능 추가 지양)
- 코드 변경 시 이유를 간단히 설명합니다

### 리팩토링 시
- 기존 동작을 변경하지 않도록 주의합니다
- 큰 변경은 작은 단계로 나누어 제안합니다
- 테스트가 있는 경우 테스트를 먼저 확인합니다

### 질문 응답 시
- 구체적인 예시 코드를 제공합니다
- 여러 옵션이 있는 경우 장단점을 설명합니다
- 관련 문서나 참고 자료를 제시합니다

<!-- ============================================ -->
<!-- 프로젝트별 커스터마이징 가이드 -->
<!-- ============================================ -->

## 🎨 프로젝트별 커스터마이징

<!--
  아래 섹션은 프로젝트별로 수정하여 사용하세요.
  예: 특정 프레임워크 규칙, 팀 컨벤션 등
-->

### 프로젝트 특화 규칙
<!-- 여기에 프로젝트별 특수 규칙을 추가하세요 -->

### 팀 컨벤션
<!-- 여기에 팀별 코딩 컨벤션을 추가하세요 -->
